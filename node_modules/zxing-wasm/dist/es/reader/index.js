import { p as Pi, a as Ai, r as Ri } from "../share.js";
import { b as Ii, Z as Hi, c as Vi, e as Bi, f as Ni, g as Zi, d as zi, h as Gi, l as Xi, m as Li, t as qi } from "../share.js";
var Vr = (() => {
  var H;
  var E = typeof document < "u" && ((H = document.currentScript) == null ? void 0 : H.tagName.toUpperCase()) === "SCRIPT" ? document.currentScript.src : void 0;
  return function(xe = {}) {
    var Br, f = xe, Nr, tr, Ue = new Promise((e, r) => {
      Nr = e, tr = r;
    }), Ie = typeof window == "object", He = typeof Bun < "u", wr = typeof WorkerGlobalScope < "u";
    typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
    var Zr = Object.assign({}, f), zr = "./this.program", S = "";
    function Ve(e) {
      return f.locateFile ? f.locateFile(e, S) : S + e;
    }
    var Gr, Cr;
    if (Ie || wr || He) {
      var Tr;
      wr ? S = self.location.href : typeof document < "u" && ((Tr = document.currentScript) === null || Tr === void 0 ? void 0 : Tr.tagName.toUpperCase()) === "SCRIPT" && (S = document.currentScript.src), E && (S = E), S.startsWith("blob:") ? S = "" : S = S.substr(0, S.replace(/[?#].*/, "").lastIndexOf("/") + 1), wr && (Cr = (e) => {
        var r = new XMLHttpRequest();
        return r.open("GET", e, !1), r.responseType = "arraybuffer", r.send(null), new Uint8Array(r.response);
      }), Gr = async (e) => {
        var r = await fetch(e, {
          credentials: "same-origin"
        });
        if (r.ok)
          return r.arrayBuffer();
        throw new Error(r.status + " : " + r.url);
      };
    }
    var Be = f.print || console.log.bind(console), z = f.printErr || console.error.bind(console);
    Object.assign(f, Zr), Zr = null, f.arguments && f.arguments, f.thisProgram && (zr = f.thisProgram);
    var nr = f.wasmBinary, ir, Xr = !1, O, F, q, ar, G, $, Lr, qr;
    function Kr() {
      var e = ir.buffer;
      f.HEAP8 = O = new Int8Array(e), f.HEAP16 = q = new Int16Array(e), f.HEAPU8 = F = new Uint8Array(e), f.HEAPU16 = ar = new Uint16Array(e), f.HEAP32 = G = new Int32Array(e), f.HEAPU32 = $ = new Uint32Array(e), f.HEAPF32 = Lr = new Float32Array(e), f.HEAPF64 = qr = new Float64Array(e);
    }
    var Yr = [], Jr = [], Qr = [];
    function Ne() {
      if (f.preRun)
        for (typeof f.preRun == "function" && (f.preRun = [f.preRun]); f.preRun.length; )
          Ge(f.preRun.shift());
      Ar(Yr);
    }
    function Ze() {
      Ar(Jr);
    }
    function ze() {
      if (f.postRun)
        for (typeof f.postRun == "function" && (f.postRun = [f.postRun]); f.postRun.length; )
          Le(f.postRun.shift());
      Ar(Qr);
    }
    function Ge(e) {
      Yr.unshift(e);
    }
    function Xe(e) {
      Jr.unshift(e);
    }
    function Le(e) {
      Qr.unshift(e);
    }
    var V = 0, K = null;
    function qe(e) {
      var r;
      V++, (r = f.monitorRunDependencies) === null || r === void 0 || r.call(f, V);
    }
    function Ke(e) {
      var r;
      if (V--, (r = f.monitorRunDependencies) === null || r === void 0 || r.call(f, V), V == 0 && K) {
        var t = K;
        K = null, t();
      }
    }
    function Pr(e) {
      var r;
      (r = f.onAbort) === null || r === void 0 || r.call(f, e), e = "Aborted(" + e + ")", z(e), Xr = !0, e += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(e);
      throw tr(t), t;
    }
    var Ye = "data:application/octet-stream;base64,", re = (e) => e.startsWith(Ye);
    function Je() {
      var e = "zxing_reader.wasm";
      return re(e) ? e : Ve(e);
    }
    var or;
    function Qe(e) {
      if (e == or && nr)
        return new Uint8Array(nr);
      if (Cr)
        return Cr(e);
      throw "both async and sync fetching of the wasm failed";
    }
    async function rt(e) {
      if (!nr)
        try {
          var r = await Gr(e);
          return new Uint8Array(r);
        } catch {
        }
      return Qe(e);
    }
    async function et(e, r) {
      try {
        var t = await rt(e), n = await WebAssembly.instantiate(t, r);
        return n;
      } catch (i) {
        z(`failed to asynchronously prepare wasm: ${i}`), Pr(i);
      }
    }
    async function tt(e, r, t) {
      if (!e && typeof WebAssembly.instantiateStreaming == "function" && !re(r) && typeof fetch == "function")
        try {
          var n = fetch(r, {
            credentials: "same-origin"
          }), i = await WebAssembly.instantiateStreaming(n, t);
          return i;
        } catch (a) {
          z(`wasm streaming compile failed: ${a}`), z("falling back to ArrayBuffer instantiation");
        }
      return et(r, t);
    }
    function nt() {
      return {
        a: Nn
      };
    }
    async function it() {
      var e;
      function r(a, s) {
        return w = a.exports, ir = w.xa, Kr(), le = w.Ba, Xe(w.ya), Ke(), w;
      }
      qe();
      function t(a) {
        r(a.instance);
      }
      var n = nt();
      if (f.instantiateWasm)
        try {
          return f.instantiateWasm(n, r);
        } catch (a) {
          z(`Module.instantiateWasm callback failed with error: ${a}`), tr(a);
        }
      (e = or) !== null && e !== void 0 || (or = Je());
      try {
        var i = await tt(nr, or, n);
        return t(i), i;
      } catch (a) {
        tr(a);
        return;
      }
    }
    var Ar = (e) => {
      for (; e.length > 0; )
        e.shift()(f);
    };
    f.noExitRuntime;
    var p = (e) => Ce(e), h = () => Te(), sr = [], ur = 0, at = (e) => {
      var r = new Rr(e);
      return r.get_caught() || (r.set_caught(!0), ur--), r.set_rethrown(!1), sr.push(r), Ae(e), be(e);
    }, W = 0, ot = () => {
      d(0, 0);
      var e = sr.pop();
      Pe(e.excPtr), W = 0;
    };
    class Rr {
      constructor(r) {
        this.excPtr = r, this.ptr = r - 24;
      }
      set_type(r) {
        $[this.ptr + 4 >> 2] = r;
      }
      get_type() {
        return $[this.ptr + 4 >> 2];
      }
      set_destructor(r) {
        $[this.ptr + 8 >> 2] = r;
      }
      get_destructor() {
        return $[this.ptr + 8 >> 2];
      }
      set_caught(r) {
        r = r ? 1 : 0, O[this.ptr + 12] = r;
      }
      get_caught() {
        return O[this.ptr + 12] != 0;
      }
      set_rethrown(r) {
        r = r ? 1 : 0, O[this.ptr + 13] = r;
      }
      get_rethrown() {
        return O[this.ptr + 13] != 0;
      }
      init(r, t) {
        this.set_adjusted_ptr(0), this.set_type(r), this.set_destructor(t);
      }
      set_adjusted_ptr(r) {
        $[this.ptr + 16 >> 2] = r;
      }
      get_adjusted_ptr() {
        return $[this.ptr + 16 >> 2];
      }
    }
    var st = (e) => {
      throw W || (W = e), W;
    }, fr = (e) => we(e), Er = (e) => {
      var r = W;
      if (!r)
        return fr(0), 0;
      var t = new Rr(r);
      t.set_adjusted_ptr(r);
      var n = t.get_type();
      if (!n)
        return fr(0), r;
      for (var i of e) {
        if (i === 0 || i === n)
          break;
        var a = t.ptr + 16;
        if (Re(i, n, a))
          return fr(i), r;
      }
      return fr(n), r;
    }, ut = () => Er([]), ft = (e) => Er([e]), lt = (e, r) => Er([e, r]), ct = () => {
      var e = sr.pop();
      e || Pr("no exception to throw");
      var r = e.excPtr;
      throw e.get_rethrown() || (sr.push(e), e.set_rethrown(!0), e.set_caught(!1), ur++), W = r, W;
    }, vt = (e, r, t) => {
      var n = new Rr(e);
      throw n.init(r, t), W = e, ur++, W;
    }, dt = () => ur, pt = () => Pr(""), lr = {}, Fr = (e) => {
      for (; e.length; ) {
        var r = e.pop(), t = e.pop();
        t(r);
      }
    };
    function Y(e) {
      return this.fromWireType($[e >> 2]);
    }
    var X = {}, B = {}, cr = {}, ee, vr = (e) => {
      throw new ee(e);
    }, N = (e, r, t) => {
      e.forEach((o) => cr[o] = r);
      function n(o) {
        var u = t(o);
        u.length !== e.length && vr("Mismatched type converter count");
        for (var l = 0; l < e.length; ++l)
          j(e[l], u[l]);
      }
      var i = new Array(r.length), a = [], s = 0;
      r.forEach((o, u) => {
        B.hasOwnProperty(o) ? i[u] = B[o] : (a.push(o), X.hasOwnProperty(o) || (X[o] = []), X[o].push(() => {
          i[u] = B[o], ++s, s === a.length && n(i);
        }));
      }), a.length === 0 && n(i);
    }, ht = (e) => {
      var r = lr[e];
      delete lr[e];
      var t = r.rawConstructor, n = r.rawDestructor, i = r.fields, a = i.map((s) => s.getterReturnType).concat(i.map((s) => s.setterArgumentType));
      N([e], a, (s) => {
        var o = {};
        return i.forEach((u, l) => {
          var c = u.fieldName, v = s[l], g = u.getter, m = u.getterContext, b = s[l + i.length], P = u.setter, C = u.setterContext;
          o[c] = {
            read: (T) => v.fromWireType(g(m, T)),
            write: (T, Z) => {
              var R = [];
              P(C, T, b.toWireType(R, Z)), Fr(R);
            }
          };
        }), [{
          name: r.name,
          fromWireType: (u) => {
            var l = {};
            for (var c in o)
              l[c] = o[c].read(u);
            return n(u), l;
          },
          toWireType: (u, l) => {
            for (var c in o)
              if (!(c in l))
                throw new TypeError(`Missing field: "${c}"`);
            var v = t();
            for (c in o)
              o[c].write(v, l[c]);
            return u !== null && u.push(n, v), v;
          },
          argPackAdvance: D,
          readValueFromPointer: Y,
          destructorFunction: n
        }];
      });
    }, _t = (e, r, t, n, i) => {
    }, gt = () => {
      for (var e = new Array(256), r = 0; r < 256; ++r)
        e[r] = String.fromCharCode(r);
      te = e;
    }, te, A = (e) => {
      for (var r = "", t = e; F[t]; )
        r += te[F[t++]];
      return r;
    }, L, y = (e) => {
      throw new L(e);
    };
    function yt(e, r) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var n = r.name;
      if (e || y(`type "${n}" must have a positive integer typeid pointer`), B.hasOwnProperty(e)) {
        if (t.ignoreDuplicateRegistrations)
          return;
        y(`Cannot register type '${n}' twice`);
      }
      if (B[e] = r, delete cr[e], X.hasOwnProperty(e)) {
        var i = X[e];
        delete X[e], i.forEach((a) => a());
      }
    }
    function j(e, r) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return yt(e, r, t);
    }
    var D = 8, mt = (e, r, t, n) => {
      r = A(r), j(e, {
        name: r,
        fromWireType: function(i) {
          return !!i;
        },
        toWireType: function(i, a) {
          return a ? t : n;
        },
        argPackAdvance: D,
        readValueFromPointer: function(i) {
          return this.fromWireType(F[i]);
        },
        destructorFunction: null
      });
    }, $t = (e) => ({
      count: e.count,
      deleteScheduled: e.deleteScheduled,
      preservePointerOnDelete: e.preservePointerOnDelete,
      ptr: e.ptr,
      ptrType: e.ptrType,
      smartPtr: e.smartPtr,
      smartPtrType: e.smartPtrType
    }), kr = (e) => {
      function r(t) {
        return t.$$.ptrType.registeredClass.name;
      }
      y(r(e) + " instance already deleted");
    }, Sr = !1, ne = (e) => {
    }, bt = (e) => {
      e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr);
    }, ie = (e) => {
      e.count.value -= 1;
      var r = e.count.value === 0;
      r && bt(e);
    }, ae = (e, r, t) => {
      if (r === t)
        return e;
      if (t.baseClass === void 0)
        return null;
      var n = ae(e, r, t.baseClass);
      return n === null ? null : t.downcast(n);
    }, oe = {}, wt = {}, Ct = (e, r) => {
      for (r === void 0 && y("ptr should not be undefined"); e.baseClass; )
        r = e.upcast(r), e = e.baseClass;
      return r;
    }, Tt = (e, r) => (r = Ct(e, r), wt[r]), dr = (e, r) => {
      (!r.ptrType || !r.ptr) && vr("makeClassHandle requires ptr and ptrType");
      var t = !!r.smartPtrType, n = !!r.smartPtr;
      return t !== n && vr("Both smartPtrType and smartPtr must be specified"), r.count = {
        value: 1
      }, J(Object.create(e, {
        $$: {
          value: r,
          writable: !0
        }
      }));
    };
    function Pt(e) {
      var r = this.getPointee(e);
      if (!r)
        return this.destructor(e), null;
      var t = Tt(this.registeredClass, r);
      if (t !== void 0) {
        if (t.$$.count.value === 0)
          return t.$$.ptr = r, t.$$.smartPtr = e, t.clone();
        var n = t.clone();
        return this.destructor(e), n;
      }
      function i() {
        return this.isSmartPointer ? dr(this.registeredClass.instancePrototype, {
          ptrType: this.pointeeType,
          ptr: r,
          smartPtrType: this,
          smartPtr: e
        }) : dr(this.registeredClass.instancePrototype, {
          ptrType: this,
          ptr: e
        });
      }
      var a = this.registeredClass.getActualType(r), s = oe[a];
      if (!s)
        return i.call(this);
      var o;
      this.isConst ? o = s.constPointerType : o = s.pointerType;
      var u = ae(r, this.registeredClass, o.registeredClass);
      return u === null ? i.call(this) : this.isSmartPointer ? dr(o.registeredClass.instancePrototype, {
        ptrType: o,
        ptr: u,
        smartPtrType: this,
        smartPtr: e
      }) : dr(o.registeredClass.instancePrototype, {
        ptrType: o,
        ptr: u
      });
    }
    var J = (e) => typeof FinalizationRegistry > "u" ? (J = (r) => r, e) : (Sr = new FinalizationRegistry((r) => {
      ie(r.$$);
    }), J = (r) => {
      var t = r.$$, n = !!t.smartPtr;
      if (n) {
        var i = {
          $$: t
        };
        Sr.register(r, i, r);
      }
      return r;
    }, ne = (r) => Sr.unregister(r), J(e)), At = () => {
      Object.assign(pr.prototype, {
        isAliasOf(e) {
          if (!(this instanceof pr) || !(e instanceof pr))
            return !1;
          var r = this.$$.ptrType.registeredClass, t = this.$$.ptr;
          e.$$ = e.$$;
          for (var n = e.$$.ptrType.registeredClass, i = e.$$.ptr; r.baseClass; )
            t = r.upcast(t), r = r.baseClass;
          for (; n.baseClass; )
            i = n.upcast(i), n = n.baseClass;
          return r === n && t === i;
        },
        clone() {
          if (this.$$.ptr || kr(this), this.$$.preservePointerOnDelete)
            return this.$$.count.value += 1, this;
          var e = J(Object.create(Object.getPrototypeOf(this), {
            $$: {
              value: $t(this.$$)
            }
          }));
          return e.$$.count.value += 1, e.$$.deleteScheduled = !1, e;
        },
        delete() {
          this.$$.ptr || kr(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && y("Object already scheduled for deletion"), ne(this), ie(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
        },
        isDeleted() {
          return !this.$$.ptr;
        },
        deleteLater() {
          return this.$$.ptr || kr(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && y("Object already scheduled for deletion"), this.$$.deleteScheduled = !0, this;
        }
      });
    };
    function pr() {
    }
    var hr = (e, r) => Object.defineProperty(r, "name", {
      value: e
    }), se = (e, r, t) => {
      if (e[r].overloadTable === void 0) {
        var n = e[r];
        e[r] = function() {
          for (var i = arguments.length, a = new Array(i), s = 0; s < i; s++)
            a[s] = arguments[s];
          return e[r].overloadTable.hasOwnProperty(a.length) || y(`Function '${t}' called with an invalid number of arguments (${a.length}) - expects one of (${e[r].overloadTable})!`), e[r].overloadTable[a.length].apply(this, a);
        }, e[r].overloadTable = [], e[r].overloadTable[n.argCount] = n;
      }
    }, ue = (e, r, t) => {
      f.hasOwnProperty(e) ? ((t === void 0 || f[e].overloadTable !== void 0 && f[e].overloadTable[t] !== void 0) && y(`Cannot register public name '${e}' twice`), se(f, e, e), f[e].overloadTable.hasOwnProperty(t) && y(`Cannot register multiple overloads of a function with the same number of arguments (${t})!`), f[e].overloadTable[t] = r) : (f[e] = r, f[e].argCount = t);
    }, Rt = 48, Et = 57, Ft = (e) => {
      e = e.replace(/[^a-zA-Z0-9_]/g, "$");
      var r = e.charCodeAt(0);
      return r >= Rt && r <= Et ? `_${e}` : e;
    };
    function kt(e, r, t, n, i, a, s, o) {
      this.name = e, this.constructor = r, this.instancePrototype = t, this.rawDestructor = n, this.baseClass = i, this.getActualType = a, this.upcast = s, this.downcast = o, this.pureVirtualFunctions = [];
    }
    var jr = (e, r, t) => {
      for (; r !== t; )
        r.upcast || y(`Expected null or instance of ${t.name}, got an instance of ${r.name}`), e = r.upcast(e), r = r.baseClass;
      return e;
    };
    function St(e, r) {
      if (r === null)
        return this.isReference && y(`null is not a valid ${this.name}`), 0;
      r.$$ || y(`Cannot pass "${xr(r)}" as a ${this.name}`), r.$$.ptr || y(`Cannot pass deleted object as a pointer of type ${this.name}`);
      var t = r.$$.ptrType.registeredClass, n = jr(r.$$.ptr, t, this.registeredClass);
      return n;
    }
    function jt(e, r) {
      var t;
      if (r === null)
        return this.isReference && y(`null is not a valid ${this.name}`), this.isSmartPointer ? (t = this.rawConstructor(), e !== null && e.push(this.rawDestructor, t), t) : 0;
      (!r || !r.$$) && y(`Cannot pass "${xr(r)}" as a ${this.name}`), r.$$.ptr || y(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && r.$$.ptrType.isConst && y(`Cannot convert argument of type ${r.$$.smartPtrType ? r.$$.smartPtrType.name : r.$$.ptrType.name} to parameter type ${this.name}`);
      var n = r.$$.ptrType.registeredClass;
      if (t = jr(r.$$.ptr, n, this.registeredClass), this.isSmartPointer)
        switch (r.$$.smartPtr === void 0 && y("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
          case 0:
            r.$$.smartPtrType === this ? t = r.$$.smartPtr : y(`Cannot convert argument of type ${r.$$.smartPtrType ? r.$$.smartPtrType.name : r.$$.ptrType.name} to parameter type ${this.name}`);
            break;
          case 1:
            t = r.$$.smartPtr;
            break;
          case 2:
            if (r.$$.smartPtrType === this)
              t = r.$$.smartPtr;
            else {
              var i = r.clone();
              t = this.rawShare(t, x.toHandle(() => i.delete())), e !== null && e.push(this.rawDestructor, t);
            }
            break;
          default:
            y("Unsupporting sharing policy");
        }
      return t;
    }
    function Ot(e, r) {
      if (r === null)
        return this.isReference && y(`null is not a valid ${this.name}`), 0;
      r.$$ || y(`Cannot pass "${xr(r)}" as a ${this.name}`), r.$$.ptr || y(`Cannot pass deleted object as a pointer of type ${this.name}`), r.$$.ptrType.isConst && y(`Cannot convert argument of type ${r.$$.ptrType.name} to parameter type ${this.name}`);
      var t = r.$$.ptrType.registeredClass, n = jr(r.$$.ptr, t, this.registeredClass);
      return n;
    }
    var Wt = () => {
      Object.assign(_r.prototype, {
        getPointee(e) {
          return this.rawGetPointee && (e = this.rawGetPointee(e)), e;
        },
        destructor(e) {
          var r;
          (r = this.rawDestructor) === null || r === void 0 || r.call(this, e);
        },
        argPackAdvance: D,
        readValueFromPointer: Y,
        fromWireType: Pt
      });
    };
    function _r(e, r, t, n, i, a, s, o, u, l, c) {
      this.name = e, this.registeredClass = r, this.isReference = t, this.isConst = n, this.isSmartPointer = i, this.pointeeType = a, this.sharingPolicy = s, this.rawGetPointee = o, this.rawConstructor = u, this.rawShare = l, this.rawDestructor = c, !i && r.baseClass === void 0 ? n ? (this.toWireType = St, this.destructorFunction = null) : (this.toWireType = Ot, this.destructorFunction = null) : this.toWireType = jt;
    }
    var fe = (e, r, t) => {
      f.hasOwnProperty(e) || vr("Replacing nonexistent public symbol"), f[e].overloadTable !== void 0 && t !== void 0 ? f[e].overloadTable[t] = r : (f[e] = r, f[e].argCount = t);
    }, Dt = (e, r, t) => {
      e = e.replace(/p/g, "i");
      var n = f["dynCall_" + e];
      return n(r, ...t);
    }, gr = [], le, _ = (e) => {
      var r = gr[e];
      return r || (e >= gr.length && (gr.length = e + 1), gr[e] = r = le.get(e)), r;
    }, Mt = function(e, r) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (e.includes("j"))
        return Dt(e, r, t);
      var n = _(r)(...t);
      return n;
    }, xt = (e, r) => function() {
      for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
        n[i] = arguments[i];
      return Mt(e, r, n);
    }, k = (e, r) => {
      e = A(e);
      function t() {
        return e.includes("j") ? xt(e, r) : _(r);
      }
      var n = t();
      return typeof n != "function" && y(`unknown function pointer with signature ${e}: ${r}`), n;
    }, Ut = (e, r) => {
      var t = hr(r, function(n) {
        this.name = r, this.message = n;
        var i = new Error(n).stack;
        i !== void 0 && (this.stack = this.toString() + `
` + i.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, t;
    }, ce, ve = (e) => {
      var r = $e(e), t = A(r);
      return U(r), t;
    }, yr = (e, r) => {
      var t = [], n = {};
      function i(a) {
        if (!n[a] && !B[a]) {
          if (cr[a]) {
            cr[a].forEach(i);
            return;
          }
          t.push(a), n[a] = !0;
        }
      }
      throw r.forEach(i), new ce(`${e}: ` + t.map(ve).join([", "]));
    }, It = (e, r, t, n, i, a, s, o, u, l, c, v, g) => {
      c = A(c), a = k(i, a), o && (o = k(s, o)), l && (l = k(u, l)), g = k(v, g);
      var m = Ft(c);
      ue(m, function() {
        yr(`Cannot construct ${c} due to unbound types`, [n]);
      }), N([e, r, t], n ? [n] : [], (b) => {
        b = b[0];
        var P, C;
        n ? (P = b.registeredClass, C = P.instancePrototype) : C = pr.prototype;
        var T = hr(c, function() {
          if (Object.getPrototypeOf(this) !== Z)
            throw new L("Use 'new' to construct " + c);
          if (R.constructor_body === void 0)
            throw new L(c + " has no accessible constructor");
          for (var Oe = arguments.length, $r = new Array(Oe), br = 0; br < Oe; br++)
            $r[br] = arguments[br];
          var We = R.constructor_body[$r.length];
          if (We === void 0)
            throw new L(`Tried to invoke ctor of ${c} with invalid number of parameters (${$r.length}) - expected (${Object.keys(R.constructor_body).toString()}) parameters instead!`);
          return We.apply(this, $r);
        }), Z = Object.create(C, {
          constructor: {
            value: T
          }
        });
        T.prototype = Z;
        var R = new kt(c, T, Z, g, P, a, o, l);
        if (R.baseClass) {
          var I, er;
          (er = (I = R.baseClass).__derivedClasses) !== null && er !== void 0 || (I.__derivedClasses = []), R.baseClass.__derivedClasses.push(R);
        }
        var Ti = new _r(c, R, !0, !1, !1), Se = new _r(c + "*", R, !1, !1, !1), je = new _r(c + " const*", R, !1, !0, !1);
        return oe[e] = {
          pointerType: Se,
          constPointerType: je
        }, fe(m, T), [Ti, Se, je];
      });
    }, Or = (e, r) => {
      for (var t = [], n = 0; n < e; n++)
        t.push($[r + n * 4 >> 2]);
      return t;
    };
    function Ht(e) {
      for (var r = 1; r < e.length; ++r)
        if (e[r] !== null && e[r].destructorFunction === void 0)
          return !0;
      return !1;
    }
    function Wr(e, r, t, n, i, a) {
      var s = r.length;
      s < 2 && y("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var o = r[1] !== null && t !== null, u = Ht(r), l = r[0].name !== "void", c = s - 2, v = new Array(c), g = [], m = [], b = function() {
        m.length = 0;
        var P;
        g.length = o ? 2 : 1, g[0] = i, o && (P = r[1].toWireType(m, this), g[1] = P);
        for (var C = 0; C < c; ++C)
          v[C] = r[C + 2].toWireType(m, C < 0 || arguments.length <= C ? void 0 : arguments[C]), g.push(v[C]);
        var T = n(...g);
        function Z(R) {
          if (u)
            Fr(m);
          else
            for (var I = o ? 1 : 2; I < r.length; I++) {
              var er = I === 1 ? P : v[I - 2];
              r[I].destructorFunction !== null && r[I].destructorFunction(er);
            }
          if (l)
            return r[0].fromWireType(R);
        }
        return Z(T);
      };
      return hr(e, b);
    }
    var Vt = (e, r, t, n, i, a) => {
      var s = Or(r, t);
      i = k(n, i), N([], [e], (o) => {
        o = o[0];
        var u = `constructor ${o.name}`;
        if (o.registeredClass.constructor_body === void 0 && (o.registeredClass.constructor_body = []), o.registeredClass.constructor_body[r - 1] !== void 0)
          throw new L(`Cannot register multiple constructors with identical number of parameters (${r - 1}) for class '${o.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
        return o.registeredClass.constructor_body[r - 1] = () => {
          yr(`Cannot construct ${o.name} due to unbound types`, s);
        }, N([], s, (l) => (l.splice(1, 0, null), o.registeredClass.constructor_body[r - 1] = Wr(u, l, null, i, a), [])), [];
      });
    }, de = (e) => {
      e = e.trim();
      const r = e.indexOf("(");
      return r !== -1 ? e.substr(0, r) : e;
    }, Bt = (e, r, t, n, i, a, s, o, u, l) => {
      var c = Or(t, n);
      r = A(r), r = de(r), a = k(i, a), N([], [e], (v) => {
        v = v[0];
        var g = `${v.name}.${r}`;
        r.startsWith("@@") && (r = Symbol[r.substring(2)]), o && v.registeredClass.pureVirtualFunctions.push(r);
        function m() {
          yr(`Cannot call ${g} due to unbound types`, c);
        }
        var b = v.registeredClass.instancePrototype, P = b[r];
        return P === void 0 || P.overloadTable === void 0 && P.className !== v.name && P.argCount === t - 2 ? (m.argCount = t - 2, m.className = v.name, b[r] = m) : (se(b, r, g), b[r].overloadTable[t - 2] = m), N([], c, (C) => {
          var T = Wr(g, C, v, a, s);
          return b[r].overloadTable === void 0 ? (T.argCount = t - 2, b[r] = T) : b[r].overloadTable[t - 2] = T, [];
        }), [];
      });
    }, Dr = [], M = [], Mr = (e) => {
      e > 9 && --M[e + 1] === 0 && (M[e] = void 0, Dr.push(e));
    }, Nt = () => M.length / 2 - 5 - Dr.length, Zt = () => {
      M.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1), f.count_emval_handles = Nt;
    }, x = {
      toValue: (e) => (e || y("Cannot use deleted val. handle = " + e), M[e]),
      toHandle: (e) => {
        switch (e) {
          case void 0:
            return 2;
          case null:
            return 4;
          case !0:
            return 6;
          case !1:
            return 8;
          default: {
            const r = Dr.pop() || M.length;
            return M[r] = e, M[r + 1] = 1, r;
          }
        }
      }
    }, pe = {
      name: "emscripten::val",
      fromWireType: (e) => {
        var r = x.toValue(e);
        return Mr(e), r;
      },
      toWireType: (e, r) => x.toHandle(r),
      argPackAdvance: D,
      readValueFromPointer: Y,
      destructorFunction: null
    }, zt = (e) => j(e, pe), xr = (e) => {
      if (e === null)
        return "null";
      var r = typeof e;
      return r === "object" || r === "array" || r === "function" ? e.toString() : "" + e;
    }, Gt = (e, r) => {
      switch (r) {
        case 4:
          return function(t) {
            return this.fromWireType(Lr[t >> 2]);
          };
        case 8:
          return function(t) {
            return this.fromWireType(qr[t >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${r}): ${e}`);
      }
    }, Xt = (e, r, t) => {
      r = A(r), j(e, {
        name: r,
        fromWireType: (n) => n,
        toWireType: (n, i) => i,
        argPackAdvance: D,
        readValueFromPointer: Gt(r, t),
        destructorFunction: null
      });
    }, Lt = (e, r, t, n, i, a, s, o) => {
      var u = Or(r, t);
      e = A(e), e = de(e), i = k(n, i), ue(e, function() {
        yr(`Cannot call ${e} due to unbound types`, u);
      }, r - 1), N([], u, (l) => {
        var c = [l[0], null].concat(l.slice(1));
        return fe(e, Wr(e, c, null, i, a), r - 1), [];
      });
    }, qt = (e, r, t) => {
      switch (r) {
        case 1:
          return t ? (n) => O[n] : (n) => F[n];
        case 2:
          return t ? (n) => q[n >> 1] : (n) => ar[n >> 1];
        case 4:
          return t ? (n) => G[n >> 2] : (n) => $[n >> 2];
        default:
          throw new TypeError(`invalid integer width (${r}): ${e}`);
      }
    }, Kt = (e, r, t, n, i) => {
      r = A(r);
      var a = (c) => c;
      if (n === 0) {
        var s = 32 - 8 * t;
        a = (c) => c << s >>> s;
      }
      var o = r.includes("unsigned"), u = (c, v) => {
      }, l;
      o ? l = function(c, v) {
        return u(v, this.name), v >>> 0;
      } : l = function(c, v) {
        return u(v, this.name), v;
      }, j(e, {
        name: r,
        fromWireType: a,
        toWireType: l,
        argPackAdvance: D,
        readValueFromPointer: qt(r, t, n !== 0),
        destructorFunction: null
      });
    }, Yt = (e, r, t) => {
      var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], i = n[r];
      function a(s) {
        var o = $[s >> 2], u = $[s + 4 >> 2];
        return new i(O.buffer, u, o);
      }
      t = A(t), j(e, {
        name: t,
        fromWireType: a,
        argPackAdvance: D,
        readValueFromPointer: a
      }, {
        ignoreDuplicateRegistrations: !0
      });
    }, Jt = Object.assign({
      optional: !0
    }, pe), Qt = (e, r) => {
      j(e, Jt);
    }, rn = (e, r, t, n) => {
      if (!(n > 0)) return 0;
      for (var i = t, a = t + n - 1, s = 0; s < e.length; ++s) {
        var o = e.charCodeAt(s);
        if (o >= 55296 && o <= 57343) {
          var u = e.charCodeAt(++s);
          o = 65536 + ((o & 1023) << 10) | u & 1023;
        }
        if (o <= 127) {
          if (t >= a) break;
          r[t++] = o;
        } else if (o <= 2047) {
          if (t + 1 >= a) break;
          r[t++] = 192 | o >> 6, r[t++] = 128 | o & 63;
        } else if (o <= 65535) {
          if (t + 2 >= a) break;
          r[t++] = 224 | o >> 12, r[t++] = 128 | o >> 6 & 63, r[t++] = 128 | o & 63;
        } else {
          if (t + 3 >= a) break;
          r[t++] = 240 | o >> 18, r[t++] = 128 | o >> 12 & 63, r[t++] = 128 | o >> 6 & 63, r[t++] = 128 | o & 63;
        }
      }
      return r[t] = 0, t - i;
    }, Q = (e, r, t) => rn(e, F, r, t), en = (e) => {
      for (var r = 0, t = 0; t < e.length; ++t) {
        var n = e.charCodeAt(t);
        n <= 127 ? r++ : n <= 2047 ? r += 2 : n >= 55296 && n <= 57343 ? (r += 4, ++t) : r += 3;
      }
      return r;
    }, he = typeof TextDecoder < "u" ? new TextDecoder() : void 0, _e = function(e) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
      for (var n = r + t, i = r; e[i] && !(i >= n); ) ++i;
      if (i - r > 16 && e.buffer && he)
        return he.decode(e.subarray(r, i));
      for (var a = ""; r < i; ) {
        var s = e[r++];
        if (!(s & 128)) {
          a += String.fromCharCode(s);
          continue;
        }
        var o = e[r++] & 63;
        if ((s & 224) == 192) {
          a += String.fromCharCode((s & 31) << 6 | o);
          continue;
        }
        var u = e[r++] & 63;
        if ((s & 240) == 224 ? s = (s & 15) << 12 | o << 6 | u : s = (s & 7) << 18 | o << 12 | u << 6 | e[r++] & 63, s < 65536)
          a += String.fromCharCode(s);
        else {
          var l = s - 65536;
          a += String.fromCharCode(55296 | l >> 10, 56320 | l & 1023);
        }
      }
      return a;
    }, tn = (e, r) => e ? _e(F, e, r) : "", nn = (e, r) => {
      r = A(r), j(e, {
        name: r,
        fromWireType(t) {
          for (var n = $[t >> 2], i = t + 4, a, s, o = i, s = 0; s <= n; ++s) {
            var u = i + s;
            if (s == n || F[u] == 0) {
              var l = u - o, c = tn(o, l);
              a === void 0 ? a = c : (a += "\0", a += c), o = u + 1;
            }
          }
          return U(t), a;
        },
        toWireType(t, n) {
          n instanceof ArrayBuffer && (n = new Uint8Array(n));
          var i, a = typeof n == "string";
          a || n instanceof Uint8Array || n instanceof Uint8ClampedArray || n instanceof Int8Array || y("Cannot pass non-string to std::string"), a ? i = en(n) : i = n.length;
          var s = Hr(4 + i + 1), o = s + 4;
          if ($[s >> 2] = i, a)
            Q(n, o, i + 1);
          else if (a)
            for (var u = 0; u < i; ++u) {
              var l = n.charCodeAt(u);
              l > 255 && (U(o), y("String has UTF-16 code units that do not fit in 8 bits")), F[o + u] = l;
            }
          else
            for (var u = 0; u < i; ++u)
              F[o + u] = n[u];
          return t !== null && t.push(U, s), s;
        },
        argPackAdvance: D,
        readValueFromPointer: Y,
        destructorFunction(t) {
          U(t);
        }
      });
    }, ge = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, an = (e, r) => {
      for (var t = e, n = t >> 1, i = n + r / 2; !(n >= i) && ar[n]; ) ++n;
      if (t = n << 1, t - e > 32 && ge) return ge.decode(F.subarray(e, t));
      for (var a = "", s = 0; !(s >= r / 2); ++s) {
        var o = q[e + s * 2 >> 1];
        if (o == 0) break;
        a += String.fromCharCode(o);
      }
      return a;
    }, on = (e, r, t) => {
      var n;
      if ((n = t) !== null && n !== void 0 || (t = 2147483647), t < 2) return 0;
      t -= 2;
      for (var i = r, a = t < e.length * 2 ? t / 2 : e.length, s = 0; s < a; ++s) {
        var o = e.charCodeAt(s);
        q[r >> 1] = o, r += 2;
      }
      return q[r >> 1] = 0, r - i;
    }, sn = (e) => e.length * 2, un = (e, r) => {
      for (var t = 0, n = ""; !(t >= r / 4); ) {
        var i = G[e + t * 4 >> 2];
        if (i == 0) break;
        if (++t, i >= 65536) {
          var a = i - 65536;
          n += String.fromCharCode(55296 | a >> 10, 56320 | a & 1023);
        } else
          n += String.fromCharCode(i);
      }
      return n;
    }, fn = (e, r, t) => {
      var n;
      if ((n = t) !== null && n !== void 0 || (t = 2147483647), t < 4) return 0;
      for (var i = r, a = i + t - 4, s = 0; s < e.length; ++s) {
        var o = e.charCodeAt(s);
        if (o >= 55296 && o <= 57343) {
          var u = e.charCodeAt(++s);
          o = 65536 + ((o & 1023) << 10) | u & 1023;
        }
        if (G[r >> 2] = o, r += 4, r + 4 > a) break;
      }
      return G[r >> 2] = 0, r - i;
    }, ln = (e) => {
      for (var r = 0, t = 0; t < e.length; ++t) {
        var n = e.charCodeAt(t);
        n >= 55296 && n <= 57343 && ++t, r += 4;
      }
      return r;
    }, cn = (e, r, t) => {
      t = A(t);
      var n, i, a, s;
      r === 2 ? (n = an, i = on, s = sn, a = (o) => ar[o >> 1]) : r === 4 && (n = un, i = fn, s = ln, a = (o) => $[o >> 2]), j(e, {
        name: t,
        fromWireType: (o) => {
          for (var u = $[o >> 2], l, c = o + 4, v = 0; v <= u; ++v) {
            var g = o + 4 + v * r;
            if (v == u || a(g) == 0) {
              var m = g - c, b = n(c, m);
              l === void 0 ? l = b : (l += "\0", l += b), c = g + r;
            }
          }
          return U(o), l;
        },
        toWireType: (o, u) => {
          typeof u != "string" && y(`Cannot pass non-string to C++ string type ${t}`);
          var l = s(u), c = Hr(4 + l + r);
          return $[c >> 2] = l / r, i(u, c + 4, l + r), o !== null && o.push(U, c), c;
        },
        argPackAdvance: D,
        readValueFromPointer: Y,
        destructorFunction(o) {
          U(o);
        }
      });
    }, vn = (e, r, t, n, i, a) => {
      lr[e] = {
        name: A(r),
        rawConstructor: k(t, n),
        rawDestructor: k(i, a),
        fields: []
      };
    }, dn = (e, r, t, n, i, a, s, o, u, l) => {
      lr[e].fields.push({
        fieldName: A(r),
        getterReturnType: t,
        getter: k(n, i),
        getterContext: a,
        setterArgumentType: s,
        setter: k(o, u),
        setterContext: l
      });
    }, pn = (e, r) => {
      r = A(r), j(e, {
        isVoid: !0,
        name: r,
        argPackAdvance: 0,
        fromWireType: () => {
        },
        toWireType: (t, n) => {
        }
      });
    }, hn = (e, r, t) => F.copyWithin(e, r, r + t), Ur = [], _n = (e, r, t, n) => (e = Ur[e], r = x.toValue(r), e(null, r, t, n)), gn = {}, yn = (e) => {
      var r = gn[e];
      return r === void 0 ? A(e) : r;
    }, ye = () => {
      if (typeof globalThis == "object")
        return globalThis;
      function e(r) {
        r.$$$embind_global$$$ = r;
        var t = typeof $$$embind_global$$$ == "object" && r.$$$embind_global$$$ == r;
        return t || delete r.$$$embind_global$$$, t;
      }
      if (typeof $$$embind_global$$$ == "object" || (typeof global == "object" && e(global) ? $$$embind_global$$$ = global : typeof self == "object" && e(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == "object"))
        return $$$embind_global$$$;
      throw Error("unable to get global object.");
    }, mn = (e) => e === 0 ? x.toHandle(ye()) : (e = yn(e), x.toHandle(ye()[e])), $n = (e) => {
      var r = Ur.length;
      return Ur.push(e), r;
    }, me = (e, r) => {
      var t = B[e];
      return t === void 0 && y(`${r} has unknown type ${ve(e)}`), t;
    }, bn = (e, r) => {
      for (var t = new Array(e), n = 0; n < e; ++n)
        t[n] = me($[r + n * 4 >> 2], "parameter " + n);
      return t;
    }, wn = Reflect.construct, Cn = (e, r, t) => {
      var n = [], i = e.toWireType(n, t);
      return n.length && ($[r >> 2] = x.toHandle(n)), i;
    }, Tn = (e, r, t) => {
      var n = bn(e, r), i = n.shift();
      e--;
      var a = new Array(e), s = (u, l, c, v) => {
        for (var g = 0, m = 0; m < e; ++m)
          a[m] = n[m].readValueFromPointer(v + g), g += n[m].argPackAdvance;
        var b = t === 1 ? wn(l, a) : l.apply(u, a);
        return Cn(i, c, b);
      }, o = `methodCaller<(${n.map((u) => u.name).join(", ")}) => ${i.name}>`;
      return $n(hr(o, s));
    }, Pn = (e) => {
      e > 9 && (M[e + 1] += 1);
    }, An = (e) => {
      var r = x.toValue(e);
      Fr(r), Mr(e);
    }, Rn = (e, r) => {
      e = me(e, "_emval_take_value");
      var t = e.readValueFromPointer(r);
      return x.toHandle(t);
    }, En = (e, r, t, n) => {
      var i = (/* @__PURE__ */ new Date()).getFullYear(), a = new Date(i, 0, 1), s = new Date(i, 6, 1), o = a.getTimezoneOffset(), u = s.getTimezoneOffset(), l = Math.max(o, u);
      $[e >> 2] = l * 60, G[r >> 2] = +(o != u);
      var c = (m) => {
        var b = m >= 0 ? "-" : "+", P = Math.abs(m), C = String(Math.floor(P / 60)).padStart(2, "0"), T = String(P % 60).padStart(2, "0");
        return `UTC${b}${C}${T}`;
      }, v = c(o), g = c(u);
      u < o ? (Q(v, t, 17), Q(g, n, 17)) : (Q(v, n, 17), Q(g, t, 17));
    }, Fn = () => 2147483648, kn = (e, r) => Math.ceil(e / r) * r, Sn = (e) => {
      var r = ir.buffer, t = (e - r.byteLength + 65535) / 65536 | 0;
      try {
        return ir.grow(t), Kr(), 1;
      } catch {
      }
    }, jn = (e) => {
      var r = F.length;
      e >>>= 0;
      var t = Fn();
      if (e > t)
        return !1;
      for (var n = 1; n <= 4; n *= 2) {
        var i = r * (1 + 0.2 / n);
        i = Math.min(i, e + 100663296);
        var a = Math.min(t, kn(Math.max(e, i), 65536)), s = Sn(a);
        if (s)
          return !0;
      }
      return !1;
    }, Ir = {}, On = () => zr || "./this.program", rr = () => {
      if (!rr.strings) {
        var e = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", r = {
          USER: "web_user",
          LOGNAME: "web_user",
          PATH: "/",
          PWD: "/",
          HOME: "/home/web_user",
          LANG: e,
          _: On()
        };
        for (var t in Ir)
          Ir[t] === void 0 ? delete r[t] : r[t] = Ir[t];
        var n = [];
        for (var t in r)
          n.push(`${t}=${r[t]}`);
        rr.strings = n;
      }
      return rr.strings;
    }, Wn = (e, r) => {
      for (var t = 0; t < e.length; ++t)
        O[r++] = e.charCodeAt(t);
      O[r] = 0;
    }, Dn = (e, r) => {
      var t = 0;
      return rr().forEach((n, i) => {
        var a = r + t;
        $[e + i * 4 >> 2] = a, Wn(n, a), t += n.length + 1;
      }), 0;
    }, Mn = (e, r) => {
      var t = rr();
      $[e >> 2] = t.length;
      var n = 0;
      return t.forEach((i) => n += i.length + 1), $[r >> 2] = n, 0;
    }, xn = (e) => 52;
    function Un(e, r, t, n, i) {
      return 70;
    }
    var In = [null, [], []], Hn = (e, r) => {
      var t = In[e];
      r === 0 || r === 10 ? ((e === 1 ? Be : z)(_e(t)), t.length = 0) : t.push(r);
    }, Vn = (e, r, t, n) => {
      for (var i = 0, a = 0; a < t; a++) {
        var s = $[r >> 2], o = $[r + 4 >> 2];
        r += 8;
        for (var u = 0; u < o; u++)
          Hn(e, F[s + u]);
        i += o;
      }
      return $[n >> 2] = i, 0;
    }, Bn = (e) => e;
    ee = f.InternalError = class extends Error {
      constructor(r) {
        super(r), this.name = "InternalError";
      }
    }, gt(), L = f.BindingError = class extends Error {
      constructor(r) {
        super(r), this.name = "BindingError";
      }
    }, At(), Wt(), ce = f.UnboundTypeError = Ut(Error, "UnboundTypeError"), Zt();
    var Nn = {
      s: at,
      w: ot,
      a: ut,
      j: ft,
      l: lt,
      M: ct,
      p: vt,
      ca: dt,
      d: st,
      Z: pt,
      sa: ht,
      Y: _t,
      na: mt,
      qa: It,
      pa: Vt,
      D: Bt,
      la: zt,
      Q: Xt,
      R: Lt,
      x: Kt,
      t: Yt,
      ra: Qt,
      ma: nn,
      N: cn,
      J: vn,
      ta: dn,
      oa: pn,
      fa: hn,
      U: _n,
      ua: Mr,
      wa: mn,
      _: Tn,
      S: Pn,
      va: An,
      ka: Rn,
      $: En,
      da: jn,
      aa: Dn,
      ba: Mn,
      ea: xn,
      W: Un,
      P: Vn,
      H: li,
      B: vi,
      T: qn,
      O: mi,
      q: oi,
      b: zn,
      C: fi,
      ha: pi,
      c: Xn,
      ga: hi,
      h: Ln,
      i: ri,
      r: ei,
      L: ui,
      v: ni,
      G: gi,
      I: si,
      z: di,
      F: $i,
      X: wi,
      V: Ci,
      k: Yn,
      f: Kn,
      e: Gn,
      g: Zn,
      K: yi,
      m: Qn,
      ia: ci,
      o: ti,
      u: ii,
      ja: ai,
      A: _i,
      n: Jn,
      E: bi,
      y: Bn
    }, w;
    it();
    var $e = (e) => ($e = w.za)(e), U = f._free = (e) => (U = f._free = w.Aa)(e), Hr = f._malloc = (e) => (Hr = f._malloc = w.Ca)(e), be = (e) => (be = w.Da)(e), d = (e, r) => (d = w.Ea)(e, r), we = (e) => (we = w.Fa)(e), Ce = (e) => (Ce = w.Ga)(e), Te = () => (Te = w.Ha)(), Pe = (e) => (Pe = w.Ia)(e), Ae = (e) => (Ae = w.Ja)(e), Re = (e, r, t) => (Re = w.Ka)(e, r, t);
    f.dynCall_viijii = (e, r, t, n, i, a, s) => (f.dynCall_viijii = w.La)(e, r, t, n, i, a, s);
    var Ee = f.dynCall_jiii = (e, r, t, n) => (Ee = f.dynCall_jiii = w.Ma)(e, r, t, n);
    f.dynCall_jiji = (e, r, t, n, i) => (f.dynCall_jiji = w.Na)(e, r, t, n, i);
    var Fe = f.dynCall_jiiii = (e, r, t, n, i) => (Fe = f.dynCall_jiiii = w.Oa)(e, r, t, n, i);
    f.dynCall_iiiiij = (e, r, t, n, i, a, s) => (f.dynCall_iiiiij = w.Pa)(e, r, t, n, i, a, s), f.dynCall_iiiiijj = (e, r, t, n, i, a, s, o, u) => (f.dynCall_iiiiijj = w.Qa)(e, r, t, n, i, a, s, o, u), f.dynCall_iiiiiijj = (e, r, t, n, i, a, s, o, u, l) => (f.dynCall_iiiiiijj = w.Ra)(e, r, t, n, i, a, s, o, u, l);
    function Zn(e, r, t, n) {
      var i = h();
      try {
        _(e)(r, t, n);
      } catch (a) {
        if (p(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function zn(e, r) {
      var t = h();
      try {
        return _(e)(r);
      } catch (n) {
        if (p(t), n !== n + 0) throw n;
        d(1, 0);
      }
    }
    function Gn(e, r, t) {
      var n = h();
      try {
        _(e)(r, t);
      } catch (i) {
        if (p(n), i !== i + 0) throw i;
        d(1, 0);
      }
    }
    function Xn(e, r, t) {
      var n = h();
      try {
        return _(e)(r, t);
      } catch (i) {
        if (p(n), i !== i + 0) throw i;
        d(1, 0);
      }
    }
    function Ln(e, r, t, n) {
      var i = h();
      try {
        return _(e)(r, t, n);
      } catch (a) {
        if (p(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function qn(e, r, t, n, i) {
      var a = h();
      try {
        return _(e)(r, t, n, i);
      } catch (s) {
        if (p(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    function Kn(e, r) {
      var t = h();
      try {
        _(e)(r);
      } catch (n) {
        if (p(t), n !== n + 0) throw n;
        d(1, 0);
      }
    }
    function Yn(e) {
      var r = h();
      try {
        _(e)();
      } catch (t) {
        if (p(r), t !== t + 0) throw t;
        d(1, 0);
      }
    }
    function Jn(e, r, t, n, i, a, s, o, u, l, c) {
      var v = h();
      try {
        _(e)(r, t, n, i, a, s, o, u, l, c);
      } catch (g) {
        if (p(v), g !== g + 0) throw g;
        d(1, 0);
      }
    }
    function Qn(e, r, t, n, i) {
      var a = h();
      try {
        _(e)(r, t, n, i);
      } catch (s) {
        if (p(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    function ri(e, r, t, n, i) {
      var a = h();
      try {
        return _(e)(r, t, n, i);
      } catch (s) {
        if (p(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    function ei(e, r, t, n, i, a) {
      var s = h();
      try {
        return _(e)(r, t, n, i, a);
      } catch (o) {
        if (p(s), o !== o + 0) throw o;
        d(1, 0);
      }
    }
    function ti(e, r, t, n, i, a) {
      var s = h();
      try {
        _(e)(r, t, n, i, a);
      } catch (o) {
        if (p(s), o !== o + 0) throw o;
        d(1, 0);
      }
    }
    function ni(e, r, t, n, i, a, s) {
      var o = h();
      try {
        return _(e)(r, t, n, i, a, s);
      } catch (u) {
        if (p(o), u !== u + 0) throw u;
        d(1, 0);
      }
    }
    function ii(e, r, t, n, i, a, s, o) {
      var u = h();
      try {
        _(e)(r, t, n, i, a, s, o);
      } catch (l) {
        if (p(u), l !== l + 0) throw l;
        d(1, 0);
      }
    }
    function ai(e, r, t, n, i, a, s, o, u) {
      var l = h();
      try {
        _(e)(r, t, n, i, a, s, o, u);
      } catch (c) {
        if (p(l), c !== c + 0) throw c;
        d(1, 0);
      }
    }
    function oi(e) {
      var r = h();
      try {
        return _(e)();
      } catch (t) {
        if (p(r), t !== t + 0) throw t;
        d(1, 0);
      }
    }
    function si(e, r, t, n, i, a, s, o, u) {
      var l = h();
      try {
        return _(e)(r, t, n, i, a, s, o, u);
      } catch (c) {
        if (p(l), c !== c + 0) throw c;
        d(1, 0);
      }
    }
    function ui(e, r, t, n, i, a, s) {
      var o = h();
      try {
        return _(e)(r, t, n, i, a, s);
      } catch (u) {
        if (p(o), u !== u + 0) throw u;
        d(1, 0);
      }
    }
    function fi(e, r, t, n) {
      var i = h();
      try {
        return _(e)(r, t, n);
      } catch (a) {
        if (p(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function li(e, r, t, n) {
      var i = h();
      try {
        return _(e)(r, t, n);
      } catch (a) {
        if (p(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function ci(e, r, t, n, i, a, s, o) {
      var u = h();
      try {
        _(e)(r, t, n, i, a, s, o);
      } catch (l) {
        if (p(u), l !== l + 0) throw l;
        d(1, 0);
      }
    }
    function vi(e, r, t, n, i, a) {
      var s = h();
      try {
        return _(e)(r, t, n, i, a);
      } catch (o) {
        if (p(s), o !== o + 0) throw o;
        d(1, 0);
      }
    }
    function di(e, r, t, n, i, a, s, o, u, l) {
      var c = h();
      try {
        return _(e)(r, t, n, i, a, s, o, u, l);
      } catch (v) {
        if (p(c), v !== v + 0) throw v;
        d(1, 0);
      }
    }
    function pi(e, r, t) {
      var n = h();
      try {
        return _(e)(r, t);
      } catch (i) {
        if (p(n), i !== i + 0) throw i;
        d(1, 0);
      }
    }
    function hi(e, r, t, n, i) {
      var a = h();
      try {
        return _(e)(r, t, n, i);
      } catch (s) {
        if (p(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    function _i(e, r, t, n, i, a, s, o, u, l) {
      var c = h();
      try {
        _(e)(r, t, n, i, a, s, o, u, l);
      } catch (v) {
        if (p(c), v !== v + 0) throw v;
        d(1, 0);
      }
    }
    function gi(e, r, t, n, i, a, s, o) {
      var u = h();
      try {
        return _(e)(r, t, n, i, a, s, o);
      } catch (l) {
        if (p(u), l !== l + 0) throw l;
        d(1, 0);
      }
    }
    function yi(e, r, t, n, i, a, s) {
      var o = h();
      try {
        _(e)(r, t, n, i, a, s);
      } catch (u) {
        if (p(o), u !== u + 0) throw u;
        d(1, 0);
      }
    }
    function mi(e, r, t, n) {
      var i = h();
      try {
        return _(e)(r, t, n);
      } catch (a) {
        if (p(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function $i(e, r, t, n, i, a, s, o, u, l, c, v) {
      var g = h();
      try {
        return _(e)(r, t, n, i, a, s, o, u, l, c, v);
      } catch (m) {
        if (p(g), m !== m + 0) throw m;
        d(1, 0);
      }
    }
    function bi(e, r, t, n, i, a, s, o, u, l, c, v, g, m, b, P) {
      var C = h();
      try {
        _(e)(r, t, n, i, a, s, o, u, l, c, v, g, m, b, P);
      } catch (T) {
        if (p(C), T !== T + 0) throw T;
        d(1, 0);
      }
    }
    function wi(e, r, t, n) {
      var i = h();
      try {
        return Ee(e, r, t, n);
      } catch (a) {
        if (p(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function Ci(e, r, t, n, i) {
      var a = h();
      try {
        return Fe(e, r, t, n, i);
      } catch (s) {
        if (p(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    var mr;
    K = function e() {
      mr || ke(), mr || (K = e);
    };
    function ke() {
      if (V > 0 || (Ne(), V > 0))
        return;
      function e() {
        var r;
        mr || (mr = !0, f.calledRun = !0, !Xr && (Ze(), Nr(f), (r = f.onRuntimeInitialized) === null || r === void 0 || r.call(f), ze()));
      }
      f.setStatus ? (f.setStatus("Running..."), setTimeout(() => {
        setTimeout(() => f.setStatus(""), 1), e();
      }, 1)) : e();
    }
    if (f.preInit)
      for (typeof f.preInit == "function" && (f.preInit = [f.preInit]); f.preInit.length > 0; )
        f.preInit.pop()();
    return ke(), Br = Ue, Br;
  };
})();
function De(E) {
  return Pi(Vr, E);
}
function Si() {
  return Ai(Vr);
}
function ji(E) {
  return De({
    overrides: E,
    equalityFn: Object.is,
    fireImmediately: !0
  });
}
function Oi(E) {
  De({
    overrides: E,
    equalityFn: Object.is,
    fireImmediately: !1
  });
}
async function Me(E, H) {
  return Ri(Vr, E, H);
}
async function Wi(E, H) {
  return Me(E, H);
}
async function Di(E, H) {
  return Me(E, H);
}
const Mi = "5bb3ce7aeedc314e24afb873bebcf366a01c27a00b21cdf2fa98b819c005c16b";
export {
  Ii as ZXING_CPP_COMMIT,
  Mi as ZXING_WASM_SHA256,
  Hi as ZXING_WASM_VERSION,
  Vi as barcodeFormats,
  Bi as binarizers,
  Ni as characterSets,
  Zi as contentTypes,
  zi as defaultReaderOptions,
  Gi as eanAddOnSymbols,
  ji as getZXingModule,
  Xi as linearBarcodeFormats,
  Li as matrixBarcodeFormats,
  De as prepareZXingModule,
  Si as purgeZXingModule,
  Me as readBarcodes,
  Di as readBarcodesFromImageData,
  Wi as readBarcodesFromImageFile,
  Oi as setZXingModuleOverrides,
  qi as textModes
};
